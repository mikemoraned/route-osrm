<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Basic</title>
    <link rel="shortcut icon" href="http://cartodb.com/assets/favicon.ico" />
    <style>
        html, body, #map {
            height: 100%;
            padding: 0;
            margin: 0;
        }
    </style>

    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <link rel="stylesheet" href="node_modules/leaflet-routing-machine/dist/leaflet-routing-machine.css" />

</head>
<body>
    <div id="map"></div>

    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="node_modules/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/immutable/3.7.6/immutable.min.js"></script>
    <script src="ngeohash.js"></script>

    <script>
        function main() {
            var map = L.map('map').setView([55.925022, -3.176715], 13);

            L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            function latLngBoundsFromHash(hash) {
                var bb = NGeoHash.decode_bbox(hash);
                var minlat = bb[0]; var minlon = bb[1]; var maxlat = bb[2]; var maxlon = bb[3];
                var southWest = L.latLng(minlat, minlon),
                        northEast = L.latLng(maxlat, maxlon),
                        bounds = L.latLngBounds(southWest, northEast);

                return bounds;
            }

            function rectFromHash(hash) {
                var bounds = latLngBoundsFromHash(hash);

                var rect = L.rectangle(bounds, {color: "#ff7800", weight: 1});

                console.log(hash, " -> ", rect);

                return rect;
            }

            function hashesCoveringMapViewAtDepth(b, depth) {
                return Immutable.fromJS(NGeoHash.bboxes(b.getSouth(), b.getWest(), b.getNorth(), b.getEast(), depth));
            }

            function hashBoundsAtDepth(latLng, depth) {
                var hash = NGeoHash.encode(latLng.lat, latLng.lng, depth);
                var bounds = latLngBoundsFromHash(hash);
                return bounds;
            }

            function smallestContainingHash(bounds, maxDepth) {
                var centre = bounds.getCenter();
                var depthBoundsPair = Immutable.Range(1,maxDepth)
                        .map(function(depth) {
                            return hashBoundsAtDepth(centre, depth);
                        })
                        .findLastEntry(function(hashBounds) {
                            return hashBounds.contains(bounds);
                        });
                return depthBoundsPair[0];
            }

            function hashesCoveringMapView(bounds, maxHashes) {
                var minDepthContainingBounds = smallestContainingHash(bounds, 9);
                var searchDepth = minDepthContainingBounds + 2;
                return Immutable.Range(minDepthContainingBounds, searchDepth + 1)
                        .map(function(depth) {
                            return hashesCoveringMapViewAtDepth(bounds, depth);
                        })
                        .findLast(function(hashes) {
                            return hashes.size <= maxHashes;
                        });
            }

            function coveringRectsLayer(map, maxHashes) {
                var hashes = hashesCoveringMapView(map.getBounds(), maxHashes);
                console.log(hashes.toArray());
                var group = L.layerGroup(
                        hashes.map(function(h) {
                            return rectFromHash(h);
                        }).toArray()
                );
                console.dir(group);
                return group;
            }

            var coveringRects;
            function fitCoveringRects() {
                if (coveringRects) {
                    map.removeLayer(coveringRects);
                }
                coveringRects = coveringRectsLayer(map, 1000);
                coveringRects.addTo(map);
            }
            map.on('zoomend', fitCoveringRects);
            map.on('viewreset', fitCoveringRects);
            map.on('moveend', fitCoveringRects);
            fitCoveringRects();
        }
        window.onload = main;
    </script>
</body>
</html>