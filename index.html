<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Basic</title>
    <link rel="shortcut icon" href="http://cartodb.com/assets/favicon.ico" />
    <style>
        html, body, #map {
            height: 100%;
            padding: 0;
            margin: 0;
        }
    </style>

    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <link rel="stylesheet" href="node_modules/leaflet-routing-machine/dist/leaflet-routing-machine.css" />

</head>
<body>
    <div id="map"></div>

    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="node_modules/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/immutable/3.7.6/immutable.min.js"></script>
    <script src="ngeohash.js"></script>

    <script>
        function main() {
            var map = L.map('map').setView([55.925022, -3.176715], 13);

            L.tileLayer('http://a.tile.stamen.com/toner/{z}/{x}/{y}.png', {
                attribution: 'stamen http://maps.stamen.com/'
            }).addTo(map);

            function latLngBoundsFromHash(hash) {
                var bb = NGeoHash.decode_bbox(hash);
                var minlat = bb[0]; var minlon = bb[1]; var maxlat = bb[2]; var maxlon = bb[3];
                var southWest = L.latLng(minlat, minlon),
                        northEast = L.latLng(maxlat, maxlon),
                        bounds = L.latLngBounds(southWest, northEast);

                return bounds;
            }

            function rectFromHash(hash) {
                var bounds = latLngBoundsFromHash(hash);

                var rect = L.rectangle(bounds, {
                    color: "#ffffff", weight: 5, opacity: 0.2
                });

                return rect;
            }

            function gridForMap(map) {
                var MAX_GRID_ELEMENTS = 700;
                var MAX_DEPTH = 8;

                function findBestDepth(bounds) {
                    return Immutable.Range(1, MAX_DEPTH + 1)
                            .takeWhile(function(depth) {
                               return buildHashes(depth, bounds).size <= MAX_GRID_ELEMENTS;
                            })
                            .last();
                }

                function buildHashes(depth, b) {
                    return Immutable.fromJS(
                            NGeoHash.bboxes(b.getSouth(), b.getWest(), b.getNorth(), b.getEast(), depth)
                    );
                }

                function buildGridLayer(hashes) {
//                    console.log(hashes.toArray());
                    var group = L.layerGroup(
                            hashes.map(function (h) {
                                return rectFromHash(h);
                            }).toArray()
                    );
//                    console.dir(group);
                    return group;
                }

                var gridLayer = null;
                var gridHashes = null;

                function drawGrid() {
                    if (gridLayer) {
                        map.removeLayer(gridLayer);
                    }
                    gridHashes = buildHashes(bestDepth, map.getBounds());
                    gridLayer = buildGridLayer(gridHashes);
                    gridLayer.addTo(map);
                }

                var bestDepth;

                function fullRedraw() {
                    console.log("full redraw");
                    bestDepth = findBestDepth(map.getBounds());
                    console.log("best depth: ", bestDepth);
                    drawGrid();
                }

                function partialRedraw() {
                    console.log("partial redraw");
                    drawGrid();
                }

                function gridCenters() {
                    return gridHashes
                            .map(function(hash) {
                                var bounds = latLngBoundsFromHash(hash);
                                return bounds.getCenter();
                            });
                }

                map.on('zoomend', fullRedraw);
                map.on('viewreset', fullRedraw);
                map.on('moveend', partialRedraw);

                return {
                    draw: fullRedraw,
                    points: gridCenters
                };
            };

            var grid = gridForMap(map);
            grid.draw();

            function pending(src, points, layer) {
                var MAX_OUTSTANDING = 6;

                var done = 0;
                var outstanding = 0;

                function info(msg) {
                    console.log("[" + src + "]: ", done, ",", outstanding, ",", points.size, ": ", msg);
                }

                function takeWaypoints() {
                    var remaining = points.skip(done);
                    var allowed = MAX_OUTSTANDING - outstanding;
                    var nextDests = remaining.take(allowed);
                    outstanding += allowed;

                    info("dispatching " + allowed);

                    return nextDests.map(function(dest) {
                        return [ { latLng: src }, { latLng: dest }];
                    });
                }

                function isComplete() {
                    return done === points.size;
                }

                function success(route) {
                    info("success " + route);
                    var line = L.Routing.line(route);
                    layer.addLayer(line);
                    done += 1;
                    outstanding -= 1;
                }

                function failure(err) {
                    info("error " + err);
                    done += 1;
                    outstanding -= 1;
                }

                return {
                    take: takeWaypoints,
                    isComplete: isComplete,
                    success: success,
                    failure: failure
                };
            }

            function routesForMap(map, grid) {
                var osrm = L.Routing.osrm();
                var routeLayer = L.layerGroup([]);
                routeLayer.addTo(map);

                var currentPending = null;

                function dispatchNext() {
                    if (currentPending) {
                        if (currentPending.isComplete()) {
                            currentPending = null;
                        }
                        else {
                            currentPending.take().forEach(function (waypoints) {
                                routeThrough(waypoints, currentPending);
                            });
                        }
                    }
                }

                function routeThrough(waypoints, pending) {
                    function handleOSRMResult(err, routes) {
                        if (!err) {
//                            console.dir(routes);
                            pending.success(routes[0]);
                        }
                        else {
//                            console.dir(err);
                            pending.failure(err);
                        }
                    }

                    osrm.route(waypoints, handleOSRMResult, {}, {});
                };

                function showAllRoutesFrom(src) {
                    if (routeLayer) {
                        map.removeLayer(routeLayer);
                    }
                    routeLayer = L.layerGroup([]);
                    routeLayer.addTo(map);
                    currentPending = pending(src, grid.points(), routeLayer);
                };

                return {
                    showAllRoutesFrom: showAllRoutesFrom,
                    start: function(interval) {
                        setInterval(dispatchNext, interval);
                    }
                };
            };
            var routes = routesForMap(map, grid);
            routes.start(200);

            map.on('click', function(e) {
                routes.showAllRoutesFrom(e.latlng);
            });
        }
        window.onload = main;
    </script>
</body>
</html>